
(* This module defines both the QAP-generation and QAP-evaluation semantics; QAPGen
   We could use more efficient data structures (arrays), and also write a reference interpreter *)
module QAPEval (* Generated by cpp QAPGen.fs > QAPEval.fs *)



type v = Val.Run.v
let mutable target = ""



(*
   *)

open LLVM
open VM

let nop = ref 0

type state = Map<Val.Native.a,v>

type guardid = DataCache.gid
type frame = Map<var,v*guardid>

let nextguard =
  let id = ref 0
  fun () -> incr id; !id



module Data =
  type infix = string * int32


  let private globals : Map<infix,v> ref = ref Map.empty


  let mutable private memorySize = 100000
  let mutable private memory = Array.create memorySize v.Void
  let mutable private stack = []
  let mutable top = 0


  type address = Val.Native.a
  let Local = Val.Native.Local
  let check (a:address) : bool =
    match a with
    | Val.Native.Local i -> i < top && memory.[i] <> v.Void
    | Val.Native.Global(g,i) ->
        match Map.tryFind (g,i) !globals with
        | None | Some v.Void -> false
        | _ -> true
  let loadRaw (a:address) : v =
    match a with
    | Val.Native.Local i -> memory.[i]
    | Val.Native.Global(g,i) ->
        match VM.Code.globalInt g with
        | Some n -> v.Int n
        | None ->
            match Map.tryFind (g,i) !globals with
            | Some v -> v
            | None -> printfn "Uninitialized %A" a; v.Void
  let storeRaw (a: address) v =
    match a with
    | Val.Native.Local i -> memory.[i] <- v
    | Val.Native.Global(g,i) -> globals := (!globals).Add((g,i),v)

  let cache = ref <| DataCache.init check loadRaw storeRaw
  let load cond gid addr = let (v,c) = DataCache.read cond gid addr !cache in cache := c; v
  let store cond gid addr v = cache := DataCache.write cond gid addr v !cache


  let ne = ref 0
  let malloc() = let e = Val.Native.Global("@Heap" + string !ne,0) in incr ne; e


  let mutable np = 0

  let init() =
    top <- 0
    cache := DataCache.init check loadRaw storeRaw
    assert (stack = [])

  let push() = stack <- top :: stack
  let pop() =
    match stack with
    | i::s -> for a = i+1 to top do
                storeRaw (Local a) v.Void
                cache := DataCache.evictByAddr (Local a) !cache
              stack <- s
              top <- i
    | _ -> failwith "data stack"

  let alloc n : address =
    let r = top
    top <- top + n
    if not(top < memorySize) then
      printf "Allocating more stack... "
      let newsize = 2*memorySize + n
      let newmemory = Array.init newsize (fun i -> if i < memorySize then memory.[i] else v.Void)
      memorySize <- newsize
      memory <- newmemory
    Local r

  let print() =
    printfn "The current stack is \n ------------------"
    for i = top-1 downto 0 do
      printfn "%4d | %A" i memory.[i]
    printf "The current globals are %A" !globals




  let memcpy_i8 cond gid (dest:address) (src:address) length align =
    assert (align = 4 && length % align = 0)
    if dest <= src then
      for i = 0 to int (length/4) - 1 do
        store cond gid (dest+i) (load cond gid (src+i))
    else
      for i = int (length/4) - 1 downto 0 do
        store cond gid (dest+i) (load cond gid (src+i))
  let memset_i8 cond gid (dest:address) v length align =
    assert (align = 4 && length % align = 0)
    for i = 0 to int (length/4) - 1 do store cond gid (dest+i) v






let nc = ref 0
let nf = ref 0

let gconsts cond op (u:v) (v:v) = match u.unknown, v.unknown with
                                    | true, true | false,false -> op u v
                                    | true, false -> op u (v*cond)
                                    | false, true -> op (u*cond) v

type mode = Prove | Verify



let rec call mode cond gid0 (f:fvar) args =
 //try
  incr nc
  if Lib.v && !nc % 1000 = 0 then printfn "calling %s." f

  let _, formals, blocks = Code.findFunDef f
  let xp = Code.xp blocks


  let frame : frame ref = ref Map.empty
  let get r : v = fst (!frame).[r]
  let set r gid (v:v) = frame := (!frame).Add(r,(v,gid))


  List.iter2 (fun (_,r) v -> set r gid0 v) formals args
  Data.push()


  let rec address = function
    | Var r when r.[0] = '@' -> Val.Native.Global(r,0)
    | Computed(t,Var r,vs) ->
                                let constOf = function Const n -> n | _ -> failwith "LLVM requires this to be const"
                                let ns = List.map constOf vs
                                address (Var r) + Code.offset t ns
    | _ -> failwith "Not a constant pointer"



  let valueCst = function
    | (Var _ | Computed (_,_,_)) as x -> v.Address(address x)
    | Const n -> v.Int n
    | _ -> v.Void



  let valueWrt (cond:v) gid (frame:frame ref) = function
    | Void | Var "undef" -> v.Void
    | Var r when r.[0] = '@' -> valueCst (Var r)
    | Var r -> let (v,g) = (!frame).[r] in
                                match v with
                                | v.Var _ | v.Bits _ when g <> gid -> let v2 = cond * v
                                                                      frame := (!frame).Add(r,(v2,gid))
                                                                      v2
                                | _ -> v
    | Computed(_,_,_)
    | Const _ as cx -> valueCst cx



  let vstring a =
      let name =
        match address a with
        | Val.Native.Global(gs,0) -> gs
        | _ -> failwithf "printf: not a constant format string: %A" a
      Code.globalStr name

  let vprintf (value:value->v) format (varargs: value list) =
      let s = vstring format
      let bits = s.Split '%'
      printf "%s" bits.[0]
      List.iteri
        (fun i v ->
          let s = bits.[i+1]
          let j = s.IndexOfAny [| 'd' ; 'u' ; 'X' ; 'x' ; 's' |]
          let w =
            if s.[j] = 's' then vstring v
            else
              match (value v).Arith, s.[j] with
              | x, _ -> x.AsString
          let size = if j = 0 then 0 else System.Int32.Parse (s.Substring (0,j))
          let pad = String.replicate (max 0 (size - w.Length)) " "
          printf "%s%s%s" pad w (s.Substring (j+1)))
        varargs

  let select (c:v) x0 x1 =
    if c = v.one then x1
    elif c = v.zero then x0
    else c * (x1 - x0) + x0

  let valuetype = function v.Var _ -> "Var" | v.Elt _ -> "Elt" | v.Int _ -> "Int" | _ -> "Other"



  let rec eval (cond:v) gid =
    let value v = valueWrt cond gid frame v

    let loada a = Data.load cond gid a
    let storea a v = Data.store cond gid a v
    let load p = loada (value p).address
    let store p v = storea (value p).address v

    let gadd = gconsts cond (+)
    let gsub = gconsts cond (-)
    let gselect c = gconsts cond (select c)

    let fieldOp0 op r = store r op ; v.Void
    let fieldOp1 op r a = store r (op (load a)) ; v.Void
    let fieldOp2 op r a b = store r (op (load a) (load b)); v.Void

    let loadfile (prefix:string) (index:int) (t:typ) (dst:v) compileTime =
        let a = dst.address
        let filename = prefix + "." + string index + ".data"
        let size = Code.tSize t
        printfn "reading %s (%d %s scalars)." filename size (if compileTime then "fixed" else "unknown")
        let pos = ref 0
        let store v = storea (a + !pos) v; incr pos
        if compileTime then
            let h = Field.IO.fopen filename Field.IO.Read
            let readI sz = store (v.Int(Field.IO.read_int sz h))
            let readQ() =
              let e = Field.IO.elem h
              if Lib.v then printfn "read elem[%5d]: %A" !pos e
              store (v.Elt e)
            Code.iter readI readQ t
            Field.IO.fclose h
        else
            let h = Field.IO.fopen filename Field.IO.Read
            let readI sz =
              let e = Field.t.ofInt32(Field.IO.read_int sz h)
              Val.Run.log e
              store (v.Var e)
            let readQ() =
              let e = Field.IO.elem h
              Val.Run.log e;
              if Lib.v then printfn "elem[%5d]: %A" !pos e
              store (v.Var e)
            Code.iter readI readQ t
            Field.IO.fclose h

        if not( !pos = size) then printf "parsing %A %d %d\n" t !pos size
        v.Address a

    function

    | Add(x,y) -> gadd (value x) (value y)
    | Sub(x,y) -> gsub (value x) (value y)
    | Mul(x,y) -> value x * value y
    | Srem(x,y) -> v.Int ((value x).native % (value y).native)
    | And(x,y) -> v.And (value x, value y)
    | Or(x,y) -> v.Or (value x, value y)
    | Xor(x,y) -> v.Xor (value x, value y)
    | Shl(x,y) -> v.Shift (value x, (value y).native )
    | Shr(x,y) -> v.Shift (value x, - (value y).native )
    | Eq(x,y) -> v.zerop (value x - value y)
    | Neq(x,y) -> v.one - v.zerop (value x - value y)
    | Select(x,x1,x0) -> gselect (value x) (value x0) (value x1)


    | Slt(x,y) | Sgt(y,x)
    | Ult(x,y) | Ugt(y,x) -> v.gt0p (value y - value x)
    | Sle(x,y) | Sge(y,x) -> v.ge0p (value y - value x)

    | Zext(x) -> value x


    | Call("@malloc",[x]) -> v.Address (Data.malloc())
    | Call("@llvm.lifetime.start",_) | Call("@llvm.lifetime.end",_) -> v.Void
    | Call("@llvm.memcpy.p0i8.p0i8.i32",[ dest; src; length; align; _] )
                   -> Data.memcpy_i8 cond gid (value dest).address (value src).address (value length).native (value align).native; v.Void
    | Call("@llvm.memset.p0i8.i32",[ dest; v0; length; align; _] )
    | Call("@llvm.memset.p0i8.i64",[ dest; v0; length; align; _] )
                   -> Data.memset_i8 cond gid (value dest).address (value v0) (value length).native (value align).native; v.Void
    | Call("@zeroAssert", [x]) -> v.zeroAssert (value x); v.Void
    | Call("@print", [x]) ->
        printfn "%6d: %A" Data.np (value x).Arith
        Data.np <- Data.np + 1;
        v.Void
    | Call("@endorse", [x]) -> v.endorse (value x).big
    | Call("@arith", [x]) -> (value x).Arith
    | Call("@bound", [x;min;max]) -> (value x).bound { QAP.Range.min = (value min).big; QAP.Range.max = (value max).big }
    | Call("@select", [t;a;b]) -> select (value t) (value b) (value a)
    | Call("@nRoot", []) -> v.nRoot()
    | Call("@runtime",[x]) -> if (value x).unknown then v.one else v.zero

    | Call("@printf", f::args) -> vprintf value f args; v.Int 0
    | Call("@puts" , [a]) -> printf "%s\n" (vstring a); v.Int 0
    | Call("@putchar", [a]) -> printf "%c" (char (value a).native); v.Int 0


    | Call("@elem_static_init",_) -> v.Void
    | Call("@elem_init" , [r] ) -> Data.store cond gid (value r).address (v.Elt Field.t.zero); v.Void

    | Call("@elem_set_ui" , [r;x]) -> Data.store cond gid (value r).address (v.coerce QAP.Semantics.elt (value x)); v.Void
    | Call("@elem_set_u32", r::xs) ->
                                      let x = List.fold (fun x d -> x * v.two32 + (value d).uint32) v.zero xs
                                      let e = v.coerce QAP.Semantics.elt x
                                      Data.store cond gid (value r).address e; v.Void
    | Call("@elem_rand" , [r] ) -> fieldOp0 (v.Elt (Field.t.random())) r
    | Call("@elem_free" , [r] ) -> fieldOp0 (v.Void) r
    | Call("@elem_modinv" , [r;a]) -> fieldOp1 (fun x -> v.Elt Field.t.one / x) r a
    | Call("@elem_div2" , [r;a]) -> fieldOp1 (fun x -> x / v.Int 2) r a
    | Call("@elem_mul3" , [r;a]) -> fieldOp1 (fun x -> x * v.Int 3) r a
    | Call("@elem_copy" , [r;x]) -> Data.store cond gid (value r).address (load x); v.Void
    | Call("@elem_neg" , [r;a]) -> fieldOp1 (fun x -> v.neg x) r a
    | Call("@elem_add" ,[r;a;b]) -> fieldOp2 (gadd) r a b
    | Call("@elem_sub" ,[r;a;b]) -> fieldOp2 (gsub) r a b
    | Call("@elem_mul" ,[r;a;b]) -> fieldOp2 (*) r a b
    | Call("@elem_get_bit", [a;x]) -> (load a).bit (value x).native
    | Call("@elem_width",[r;a;x]) -> fieldOp1 (fun v -> v.bound (QAP.Range.uint (value x).native)) r a
    | Call("@elem_eq_zero", [a]) -> let x = load a in (*printfn "eqz? %A" x.elt;*) v.zerop x
    | Call("@elem_cmp" , [a;b]) -> v.Int (Field.t.cmpf ((load a).elt, (load b).elt))
    | Call("@elem_dbg_print",[p]) -> printf "%A" (load p).Arith; v.Void




    | Call(f,[i0;i]) when f = (if Bank.bootstrap then "@__Enter_BOOT" else "@__Enter") ->
                                      Bank.outsourced <- []
                                      let f = Bank.s.functions.[(value i0).native]
                                      match mode with
                                        | Prove -> QAP.load f.qap; Val.Run.enter(); nop := 0; v.one
                                        | Verify -> v.zero
    | Call(f,i0::i::args) when f = (if Bank.bootstrap then "@Verify_BOOT" else "@Verify") ->

                                      let callee = (value i0).native
                                      let instance = (value i).native
                                      let f = Bank.s.functions.[callee]


                                      let resultType, formals, _ = VM.Code.findFunDef ("@"+f.name)
                                      let ts =
                                        List.map2
                                          (fun (typ,_) arg ->
                                            match Bank.of_type typ with
                                            | Some b -> b.name, (loada (value arg).address).native
                                            | None -> failwith "compile-time arguments not supported yet" )
                                          formals args

                                      let br =
                                        match Bank.of_type resultType with
                                        | Some b -> b
                                        | None -> failwith "assuming a bank result for now"
                                      let vr = eval cond gid (Call("@alloc_"+br.name,[]))
                                      let tr = (loada vr.address).native
                                      Bank.outsourced <- ts @ [br.name, tr]
                                      Bank.Verify.proof instance callee
                                      if Lib.bv then printfn "[%5d.%5d ] return verified proof on %A" callee instance Bank.outsourced
                                      vr
    | Call(f,[i0;i]) when f = (if Bank.bootstrap then "@__Exit_BOOT" else "@__Exit") ->
                                      let callee = (value i0).native
                                      let instance = (value i).native
                                      match mode with
                                      | Prove ->
                                          let internals = Array.init Val.Run.inter.Count (fun i -> Val.Run.inter.[i+1])
                                          Bank.Prove.proof instance callee internals
                                          if Lib.bv then printfn "[%5d.%5d ] return with proof on %A (%d steps)" callee instance Bank.outsourced !nop

                                      | Verify ->
                                          ()
                                      v.Void

    | Call(f,[b;p]) when Lib.w && f.StartsWith "@load_"
                               && Map.exists (fun name _ -> name = f.Substring 6) Bank.s.banks ->

                                      let a = (value p).address
                                      let name = f.Substring 6
                                      let bank = Bank.bank name
                                      let size = bank.spec.Length
                                      let callee, instance = (loada (Bank.state_function())).native, (loada (Bank.state_instance())).native
                                      let bv = (value b).address
                                      let t = (loada bv).native
                                      let top = (callee = Bank.TOP_LEVEL)
                                      if not top then Bank.outsourced <- Bank.outsourced @ [name,t]
                                      let values = bank.values.[t]
                                      if Lib.bv then printfn "[%5d.%5d ] load %s %d (%d integers)" callee instance name t size
                                      let intify (e: Field.t) = v.Int(int e.Big)
                                      let wrap = if top then intify else v.Var
                                      Array.iteri (fun k e -> storea (a+k) (wrap e)) values
                                      v.Void





    | Call(f,[b;p]) as call when Lib.w && f.StartsWith "@store_"
                                       && Map.exists (fun name _ -> name = f.Substring 7) Bank.s.banks ->

                                      let a = (value p).address
                                      let name = f.Substring 7
                                      let bank = Bank.bank name
                                      let size = bank.spec.Length
                                      let callee, instance = (loada (Bank.state_function())).native, (loada (Bank.state_instance())).native
                                      let bv = (value b).address
                                      let t = (loada bv).native
                                      let values =
                                        if callee = Bank.TOP_LEVEL then

                                          Array.init size (fun k -> Field.t.ofInt32 (loada (a+k)).native)

                                        else


                                          Bank.outsourced <- Bank.outsourced @ [name,t]
                                          Array.init size
                                            (fun k -> let v = loada (a + k)
                                                      if Lib.v then printfn "%d -> %A" k v
                                                      v.output )

                                      if Lib.bv then printfn "[%5d.%5d ] save %s %d (%d integers)" callee instance name (loada bv).native size
                                      bank.values <- bank.values.Add(t,values)

                                      v.Void



    | Call("@load_int32s",[prefix;index;size;dst;flag]) ->
                                      let s = (value size).native
                                      let t = LLVM.Array(s, LLVM.Int 32)
                                      let r = loadfile (vstring prefix) (value index).native t (value dst) ((value flag).native = 1)

                                      r
    | Call("@load_cCommitment" as f,[prefix;dst;index;flag]) ->
                                      let tname = f.Substring 6
                                      let t = Tvar("%struct." + tname)
                                      loadfile ("commit-" + vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call("@load_cProof" as f,[prefix;dst;index;flag]) ->
                                      let tname = f.Substring 6
                                      let t = Tvar("%struct." + tname)
                                      loadfile ("proof-" + vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,[prefix;dst;index;flag]) when f.StartsWith "@load_" ->
                                      let tname = f.Substring 6
                                      let t = Tvar("%struct." + tname)
                                      loadfile (vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,[dst;index;flag]) when f.StartsWith "@load_" ->
                                      let tname = f.Substring 6
                                      let t = Tvar("%struct." + tname)
                                      loadfile tname (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,args) ->
                      if Lib.i then printfn "calling %s" f
                      call mode cond gid f (List.map value args)

    | Phi(join) -> failwith "Internal error: Phi should have been dealt with outside of eval"

    | Load(x) -> load x
    | Addr(t,a,vs) ->
                      let ns = List.map (fun v -> int32 (value v).native) vs
                      let offset = Code.offset t ns

                      v.Address((value a).address + offset)
    | Alloc(t) -> v.Address (Data.alloc (Code.tSize t))
    | AllocN(t,x) -> v.Address (Data.alloc (Code.tSize t * (value x).native))
    | BitCast(_t,x) -> value (Var x)



  let result = ref None
  let predCount = Map.map (fun _ -> List.length) <| CfgAnnotator.mkIndegs (CfgAnnotator.LLVMCfg(xp.Segment))

  (* Used right before executing a branch: returns a frame for the next
     basic block. Looks ahead at the Phi() instructions of the destination
     and copies current variables to the next frame. The next frame is then returned
     We still need to copy the formal parameters, which is not done here.
     Assumes !frame and xp.label are still unchanged
  *)
  let phiAssocs value gid dest =
    let destblock = List.find (fun b -> b.label = dest) blocks
    let destphi = List.choose (function
                    | Let(v,Phi p) -> let (_,src) = List.find (fun (l,_) -> l=xp.Label) p
                                      let v2 = value <| match src with None -> Void | Some x -> x
                                      Some (v,(v2,gid))
                    | _ -> None) destblock.instr
    Map.ofList destphi

  let phiVars dest =
    let destblock = List.find (fun b -> b.label = dest) blocks
    List.choose (function Let(v,Phi _) -> Some v | _ -> None) destblock.instr

  let (&&&) (a:v) (b:v) =
    let toBit (x:v) = (*if x.isBit then x else*) v.one - v.zerop x
    if a = v.zero || b = v.zero then v.zero
    elif a = v.one then toBit b
    elif b = v.one then toBit a
    else toBit a * toBit b


  let nestedConds (outer:v) (inner:v) =
    if outer = v.zero then v.zero, v.zero
    elif inner = v.one then v.zero, outer
    elif inner = v.zero then outer, v.zero
    else
        let c1 = outer &&& inner
        let c0 = (outer - c1).bound QAP.Range.bit
        c0, c1

  (*
     *)

  let rec execBranch toplevel (cond:v) (gid:guardid) lbl0 : string * int =
      let value v = valueWrt cond gid frame v
      let lblc = ref lbl0
      let joinCount = ref 1
      let branchFrameResolved dest =
          lblc := dest
          xp.Goto dest
          if not (cond = v.zero) && Lib.i then printfn "branch %s" dest
      let branch dest =
          if not (cond = v.zero) then
              let newvars = phiAssocs value gid dest
              frame := Lib.mapUnion !frame newvars
          branchFrameResolved dest
      branch lbl0
      while (!result).IsNone && (predCount.[!lblc] = !joinCount || toplevel) do
        joinCount := 1
        let op = xp.Next
        if Lib.i then
          let nw, nr =



            Val.Run.nWire, QAP.nRoot

          printf "%8d +%6d (%6dw,%6dr) | " !nc Data.top nw nr

        incr nop;
        match op with
        | Let(_, Phi _) -> ()
        | Let(r,e) -> if cond <> v.zero then
                             let v = eval cond gid e
                             set r gid v
                             if Lib.i then printfn "%s = %A" r v
        | Store(a,x) ->
                           let l = (value a).address
                           let v = value x
                           Data.store cond gid l v
                           if Lib.i then
                             printfn "%A <- %A" l v
        | Branch(lbl) -> branch lbl
        | BranchIf(z,l1,l0) ->
                    let x = get z
                    if not x.unknown && toplevel
                    then

                      branch (if x.True then l1 else l0)
                    elif not Lib.fork then failwith "Branching on runtime conditions disabled at command line"
                    else


                        let branchAndReset c lbl =
                            let f0 = !frame
                            let start = xp.Label
                            let gid = nextguard()
                            let (endl,jc) = execBranch false c gid lbl
                            let f1 = !frame
                            xp.Goto start
                            frame := f0
                            Data.cache := DataCache.evictByGuard gid !Data.cache
                            (endl,jc,f1,gid)
                        let c0,c1 = nestedConds cond x
                        let end0, jc0, f0, g0 = branchAndReset c0 l0
                        let end1, jc1, f1, g1 = branchAndReset c1 l1
                        if end0<>end1 then failwith "Invalid control flow; only if/else is supported under runtime control"
                        joinCount := jc0 + jc1


                        if not cond.knownFalse then
                            if x.unknown then
                                let mapkeys m = List.map fst (Map.toList m)
                                let newframe : frame = Map.ofList <| List.map (fun v ->
                                          let v0 = valueWrt c0 g0 (ref f0) <| Var v
                                          let v1 = valueWrt c1 g1 (ref f1) <| Var v
                                          match v0,v1 with
                                          | v.Address a0,v.Address a1 when a0=a1 -> (v,(v0,gid))
                                          | _ -> (v,((v0+v1),gid))) (phiVars end0)
                                frame := Lib.mapUnion !frame newframe
                            elif x = v.one then frame:=f1
                            else frame:=f0
                        branchFrameResolved end0
        | Switch(x,l0,branches) ->
                        if (get x).unknown || cond.unknown then failwith "Switches in conditionals: not implemented"
                        let s = get x
                        let l =
                            match List.tryFind (fun (c,l) -> (v.zerop (value c - s)).True) branches with
                            | Some (_,l) -> l
                            | None -> l0
                        branch l
        | Return(x) ->
                      if not toplevel then failwith "Cannot return from a conditional context"
                      result := Some(value x)
                      if Lib.i then printfn "return %A from %s" result f
      (!lblc,!joinCount)


  let _,_ = execBranch true cond gid0 xp.Label
  assert (!result).IsSome
  Data.pop()
  (!result).Value

 //with exn -> printfn "from calling %s" f; raise exn





let pushArray (vs:v array) =
  let p = Data.alloc vs.Length
  Array.iteri (fun i v -> Data.storeRaw (p+i) v) vs
  v.Address p


let private pullArray (p:Data.address) ns =

  for i = 0 to Array.length ns - 1 do ns.[i] <- (Data.loadRaw (p+i)).native


let main mode =
  let name = "main"
  let gid = nextguard()
  let actuals = []
  let exitval = call mode v.one gid "@main" actuals
  exitval.native


let eval f (actuals: (string * Bank.v) list) (banks: Bank.b array) =
  Data.init()
  let mode = Prove



  Val.Run.enter()



  let frame =
    List.map
      (fun (name,actual) ->
          match actual with
            | Bank.Cfg ns ->
                let vs = Array.map v.Int ns
                pushArray vs
            | Bank.Bank b ->
                if Lib.w then v.Int 42
                else
                  let vs =



                    b.value

                  pushArray vs )
      actuals


  if Lib.w then
    Val.banks <- Array.map (fun (b:Bank.b) -> b.name, Val.bank b.name b.spec.Length) banks


  if Lib.i then Data.print()
  let gid = nextguard()
  if Lib.w then
    let init = if Bank.bootstrap then "@init_BOOT" else "@init"
    let _ = call mode v.one gid init [] in ()
  let result = call mode v.one gid f frame
  if Lib.i then Data.print()


  if not Lib.w then
    let _k =
      List.fold2
       (fun k (name,actual) (v:v) ->
        match actual with
        | Bank.Cfg ns -> pullArray v.address ns ; k
        | Bank.Bank b ->
            let size = b.spec.Length
            let p = v.address
            for i = 0 to size-1 do
              let final = Data.loadRaw (p+i)
              let assigned =
                match QAP.Log.hint() with
                | QAP.Log.Output b -> b
                | _ -> failwith "bad hint"
              if assigned then
                let v = final.output
                b.value.[i] <- Val.Run.Var v

            k + size )

       1
       actuals
       frame
    ()
  if Lib.h then
          let histogram = Array.zeroCreate 255;
          Map.iter (fun _ (x: Field.t) -> let i = QAP.log2 (x.Big + QAP.one) in histogram.[i] <- histogram.[i] + 1) Val.Run.inter
          printfn "#bit #variable\n"
          Array.iteri (fun i n -> if n <> 0 then printfn "%3d %7d" i n) histogram

  if Lib.v then

    printfn "The internal values are %A." Val.Run.inter
