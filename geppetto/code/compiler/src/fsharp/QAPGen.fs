
(* This module defines both the QAP-generation and QAP-evaluation semantics; QAPGen
   We could use more efficient data structures (arrays), and also write a reference interpreter *)

#if Gen
module QAPGen   

/// abstract values at compile-time 
type v = Val.v
#else
#line 11 "QAPEval.fs"
module QAPEval (* Generated by cpp QAPGen.fs > QAPEval.fs *)

/// abstract values at run-time 
/// e.g. using field elements instead of int32
type v = Val.Run.v
let mutable target = ""

#endif

(* /* using C-style comments for the pre-processor

type v = Val.v or Val.Run.v, depending on if we are compiling QAPGen.fs or QAPEval.fs, respectively
                             they are the values pointed to by symbol tables while interpreting things.
                             These values are held in one of three places:
                             * Data.globals - Global variables. This map has keys of type (varname*index)
                                              to refer to varname[index]. Index is always zero if varname
                                              is not an array
                             * Data.memory  - This is for local variables, although we don't seem to call 
                                              them "local" here. It corresponds to things allocated using
                                              llvm's alloca instruction, which is managed here by 
                                              Data.push; alloc*; pop
                             * frame        - These are what we usually mean when we say locals, even though
                                              in llvm lingo these are "registers". This is what holds the
                                              results of each individual instructions as they are executed
type value = LLVM.value      these are just the AST node elements we obtain from parsing, and are part of the
                             instructions we are executing (e.g. Add(value,value). They are translated to
                             v by performing lookups in the three maps above using functions of valueWrt 
                             family. Not to be confused with ...
let value : value -> v       This is a function with the same exact name as the type. It performs bulk of the 
                             symbol lookup work just mentioned. Well, actually it only looks up frame and 
                             globals; Data.memory is probably accessed directly by Data.load/store functions 
                             only.
type var = string            Variable name, one particular type of 'value' 
                             (i.e. type value = Var of var | ...)
constructor Var              Two of these: value.Var and v.Var. The former is related to the AST node,
                             while the latter represents a runtime value which was not known at keygen time.
type QAP.value               Another one, which doesn't seem to be directly used anywhere in this file (yet).
                             But this is the parameter type used in type Val.v = Var of value | ...
                             So it stores everything about a value if it actually appears in the QAP (is a
                             tuple of semantics * range * linear).
*/ *)

open LLVM
open VM 

let nop = ref 0 // number of executed LLVM instructions

type state = Map<Val.Native.a,v>
// The terms guard and cond is used interchangably in this file (make it consistent? --> use cond)
type guardid = DataCache.gid 
type frame = Map<var,v*guardid>

let nextguard = 
  let id = ref 0
  fun () -> incr id; !id


/// data: stack-allocated and statically-allocated
module Data =
  type infix = string * int32 

  // fully dynamic global allocation; pre-allocate? use a hash table?
  let private globals : Map<infix,v> ref = ref Map.empty 

  // basic stack allocation
  let mutable private memorySize = 100000
  let mutable private memory = Array.create memorySize v.Void
  let mutable private stack = []
  let mutable top = 0 


  type address = Val.Native.a // declared earlier to break a cycle
  let Local = Val.Native.Local
  let check (a:address) : bool = 
    match a with
    | Val.Native.Local i     -> i < top && memory.[i] <> v.Void
    | Val.Native.Global(g,i) -> 
        match Map.tryFind (g,i) !globals with 
        | None | Some v.Void -> false 
        | _ -> true
  let loadRaw (a:address) : v = 
    match a with 
    | Val.Native.Local i     -> memory.[i]
    | Val.Native.Global(g,i) -> 
        match VM.Code.globalInt g with 
        | Some n -> v.Int n
        | None -> 
            match Map.tryFind (g,i) !globals with 
            | Some v -> v
            | None -> printfn "Uninitialized %A" a; v.Void
  let storeRaw (a: address) v = 
    match a with 
    | Val.Native.Local i     -> memory.[i] <- v
    | Val.Native.Global(g,i) -> globals := (!globals).Add((g,i),v) 

  let cache = ref <| DataCache.init check loadRaw storeRaw
  let load  cond gid addr   = let (v,c) = DataCache.read cond gid addr !cache in cache := c; v
  let store cond gid addr v = cache := DataCache.write cond gid addr v !cache

  // malloc'ing elements (not GCed).
  let ne = ref 0
  let malloc() = let e = Val.Native.Global("@Heap" + string !ne,0) in incr ne; e  

  // sequence number for @print, for trace debugging 
  let mutable np = 0
  
  let init() = 
    top <- 0 
    cache := DataCache.init check loadRaw storeRaw
    assert (stack = [])

  let push() = stack <- top :: stack  
  let pop()  = 
    match stack with 
    | i::s -> for a = i+1 to top do 
                storeRaw (Local a) v.Void
                cache := DataCache.evictByAddr (Local a) !cache
              stack <- s 
              top   <- i
    | _  -> failwith "data stack"
    
  let alloc n : address = 
    let r = top
    top <- top + n
    if not(top < memorySize) then
      printf "Allocating more stack... " 
      let newsize   = 2*memorySize + n 
      let newmemory = Array.init newsize (fun i -> if i < memorySize then memory.[i] else v.Void)
      memorySize <- newsize
      memory <- newmemory
    Local r  
    
  let print() =
    printfn "The current stack is \n ------------------" 
    for i = top-1 downto 0 do
      printfn "%4d | %A" i memory.[i]
    printf "The current globals are %A" !globals

  /// see llvm.memcpy intrinsic; 
  /// we check align = 4 then assume those are all int32s underneath
  /// beware as we start copying pointers! 
  let memcpy_i8 cond gid (dest:address) (src:address) length align = 
    assert (align = 4 && length % align = 0)
    if dest <= src then 
      for i = 0 to int (length/4) - 1 do 
        store cond gid (dest+i) (load cond gid (src+i))
    else
      for i = int (length/4) - 1 downto 0 do
        store cond gid (dest+i) (load cond gid (src+i))
  let memset_i8 cond gid (dest:address) v length align =
    assert (align = 4 && length % align = 0)
    for i = 0 to int (length/4) - 1 do store cond gid (dest+i) v

// end of module Data
// consider partitioning Data into smaller banks, towards QAP partitioning
  
//----------------- function-call interpreter  

let nc = ref 0 // number of calls
let nf = ref 0 // number of loaded files

let gconsts cond op (u:v) (v:v) = match u.unknown, v.unknown with
                                    | true, true | false,false -> op u v
                                    | true, false -> op u (v*cond)
                                    | false, true -> 
                                         let u' = u*cond 
                                         op u' v

type mode = Prove | Verify // only meaningful for evaluation

/// function-call interpreter
/// using a shallow embedding of the control stack in F#.
let rec call mode cond gid0 (f:fvar) args = 
 //try // for tracing, otherwise not great.
  incr nc
  if Lib.v && !nc % 100 = 0 then printfn "%8d k | calling e.g. %s" QAP.nWire f
  
  let _, formals, blocks = Code.findFunDef f  
  let xp = Code.xp blocks // code address register

  // local registers, indexed by their source string 
  let frame : frame ref = ref Map.empty 
  let get r : v         = fst (!frame).[r]
  let set r gid (v:v)   = frame := (!frame).Add(r,(v,gid))
  
  // the function arguments are the initial locals
  List.iter2 (fun (_,r) v -> set r gid0 v) formals args
  Data.push() // record stack pointer for de-allocation

  /// Converts constant pointer expressions (LLVM.value) to pointer values (Val.Native.a) 
  let rec address = function
    | Var r when r.[0] = '@' -> Val.Native.Global(r,0)
    | Computed(t,Var r,vs)   -> 
                                let constOf = function Const n -> n | _ -> failwith "LLVM requires this to be const"
                                let ns = List.map constOf vs
                                address (Var r) + Code.offset t ns
    | _ -> failwith "Not a constant pointer"

  // Converts constant expressions to values (Val.v or Val.Run.v)
  // Can be called without a frame and other context parameters
  let valueCst = function
    | (Var _ | Computed (_,_,_)) as x -> v.Address(address x) // pointer to global
    | Const n -> v.Int n
    | _ -> v.Void

  // We don't guard constants here since they may be used in address calculation later on. 
  // Instead constants are processed in eval below
  let valueWrt (cond:v) gid (frame:frame ref) = function
    | Void | Var "undef"     -> v.Void
    | Var r when r.[0] = '@' -> valueCst (Var r)
    | Var r                  -> let (v,g) = (!frame).[r] in
                                match v with
                                | v.Var _ | v.Bits _ when g <> gid -> let v2 = cond * v
                                                                      frame := (!frame).Add(r,(v2,gid))
                                                                      v2
                                | _ -> v
    | Computed(_,_,_) 
    | Const _ as cx          -> valueCst cx


  // limited support for printf, convenient for debugging
  let vstring a = 
      let name = 
        match address a with 
        | Val.Native.Global(gs,0) -> gs
        | _                       -> failwithf "printf: not a constant format string: %A" a 
      Code.globalStr name
      
  let vprintf (value:value->v) format (varargs: value list) = 
      let s = vstring format
      let bits = s.Split '%' 
      printf "%s" bits.[0]
      List.iteri
        (fun i v ->
          let s = bits.[i+1]
          let j = s.IndexOfAny [| 'd' ; 'u' ; 'X' ; 'x' ; 's' |]
          let w = 
            if s.[j] = 's' then vstring v
            else
              match (value v).Arith, s.[j] with // this should be in Val
              | x, _   -> x.AsString
          let size = if j = 0 then 0 else System.Int32.Parse (s.Substring (0,j))
          let pad = String.replicate (max 0 (size - w.Length)) " " 
          printf "%s%s%s" pad w (s.Substring (j+1)))  
        varargs

  let select (c:v) x0 x1 = 
    if   c = v.one then x1 
    elif c = v.zero then x0 
    else c * (x1 - x0) + x0  // no need to select on locals? 

  let valuetype = function v.Var _ -> "Var" | v.Elt _ -> "Elt" | v.Int _ -> "Int" | _ -> "Other"
  
  // at compile-time, the unknown cond keeps track of conditional evaluation.
  // at run-time, if not(cond) then we do not care about produced values (all 0s)
  let rec eval (cond:v) gid = 
    let value v = valueWrt cond gid frame v
    // C-style primitive field operation, passing 3 pointers to abstract values
    let loada  a   = Data.load  cond gid a
    let storea a v = Data.store cond gid a v
    let load p     = loada  (value p).address
    let store p v  = storea (value p).address v
    // This is where we deal with constants
    let gadd = gconsts cond (+)
    let gsub = gconsts cond (-)
    let gselect c = gconsts cond (select c)

    let fieldOp0 op r     = store r op                    ; v.Void 
    let fieldOp1 op r a   = store r (op (load a))         ; v.Void
    let fieldOp2 op r a b = store r (op (load a) (load b)); v.Void

    let loadfile (prefix:string) (index:int) (t:typ) (dst:v) compileTime = // where should this code go?
        let a = dst.address
        let filename = prefix + "." + string index + ".data" 
        let size = Code.tSize t
        printfn "reading %s (%d %s scalars)." filename size (if compileTime then "fixed" else "unknown") 
        let pos = ref 0
        let store v = storea (a + !pos) v; incr pos // storing each value read off the file
        if compileTime then 
            let h = Field.IO.fopen filename Field.IO.Read
            let readI sz = store (v.Int(Field.IO.read_int sz h))
            let readQ() = 
              let e = Field.IO.elem h
              if Lib.v then printfn "read elem[%5d]: %A" !pos e                                            
              store (v.Elt e)
            Code.iter readI readQ t
            Field.IO.fclose h
        else 
          // we allocate local Vars instead
          #if Gen
            let readI sz = 
              // conventionally, we read only unsigned integers.
              let semantics = 
                match sz with 
                |  8 -> QAP.Semantics.uint8
                | 16 -> QAP.Semantics.uint16
                | 32 -> QAP.Semantics.uint32
                |  _ -> failwith "unsupported integer read"
              store (Val.newWire QAP.Local semantics)
            let readQ() = 
              let e = Val.newWire QAP.Local QAP.Semantics.elt 
              if Lib.v then printfn "elem[%5d]: %A" !pos e
              store e
            Code.iter readI readQ t
          #else
            let h = Field.IO.fopen filename Field.IO.Read
            let readI sz = 
              let e = Field.t.ofInt32(Field.IO.read_int sz h)
              Val.Run.log e
              store (v.Var e)
            let readQ() = 
              let e = Field.IO.elem h
              Val.Run.log e;
              if Lib.v then printfn "elem[%5d]: %A" !pos e
              store (v.Var e)
            Code.iter readI readQ t
            Field.IO.fclose h
          #endif
        if not( !pos = size) then printf "parsing %A %d %d\n" t !pos size 
        v.Address a

    function
    // basis operations
    | Add(x,y)     -> gadd (value x) (value y)
    | Sub(x,y)     -> gsub (value x) (value y)
    | Mul(x,y)     -> value x * value y
    | Srem(x,y)    -> v.Int ((value x).native % (value y).native)
    | And(x,y)     -> v.And (value x, value y)
    | Or(x,y)      -> v.Or  (value x, value y)
    | Xor(x,y)     -> v.Xor (value x, value y)
    | Shl(x,y)     -> v.Shift (value x, (value y).native )
    | Shr(x,y)     -> v.Shift (value x, - (value y).native )
    | Eq(x,y)      -> v.zerop (value x - value y)
    | Neq(x,y)     -> v.one - v.zerop (value x - value y)
    | Select(x,x1,x0) -> gselect (value x) (value x0) (value x1)
    
    // beware, we ignore signs in comparisons! This is  partial support
    | Slt(x,y) | Sgt(y,x)
    | Ult(x,y) | Ugt(y,x) -> v.gt0p (value y - value x) 
    | Sle(x,y) | Sge(y,x) -> v.ge0p (value y - value x) 
    
    | Zext(x)      -> value x

    // control & memory
    | Call("@malloc",[x]) -> v.Address (Data.malloc())
    | Call("@llvm.lifetime.start",_) | Call("@llvm.lifetime.end",_) -> v.Void
    | Call("@llvm.memcpy.p0i8.p0i8.i32",[ dest; src; length; align; _] )
                   -> Data.memcpy_i8 cond gid (value dest).address (value src).address (value length).native (value align).native; v.Void 
    | Call("@llvm.memset.p0i8.i32",[ dest; v0; length; align; _] )
    | Call("@llvm.memset.p0i8.i64",[ dest; v0; length; align; _] )
                   -> Data.memset_i8 cond gid (value dest).address (value v0) (value length).native (value align).native; v.Void 
    | Call("@zeroAssert", [x]) -> v.zeroAssert (value x); v.Void
    | Call("@print", [x])      -> 
        printfn "%6d: %A" Data.np (value x).Arith
        Data.np <- Data.np + 1; 
        v.Void
    | Call("@endorse", [x])        -> v.endorse (value x).big  
    | Call("@arith", [x])          -> (value x).Arith  
    | Call("@bound", [x;min;max])  -> (value x).bound { QAP.Range.min = (value min).big; QAP.Range.max = (value max).big }
    | Call("@select", [t;a;b])     -> select (value t) (value b) (value a)
    | Call("@nRoot", [])           -> v.nRoot()
    | Call("@runtime",[x])         -> if (value x).unknown then v.one else v.zero

    | Call("@printf", f::args)     -> vprintf value f args; v.Int 0
    | Call("@puts"   , [a])        -> printf "%s\n" (vstring a); v.Int 0
    | Call("@putchar", [a])        -> printf "%c" (char (value a).native); v.Int 0
        
    // primitive field operations (see PrimitiveIfc.h)
    | Call("@elem_static_init",_)  -> v.Void
    | Call("@elem_init"   , [r]  ) -> Data.store cond gid (value r).address (v.Elt Field.t.zero); v.Void
                                      // we used to initialize to void, but that breaks conditional execution
    | Call("@elem_set_ui" , [r;x]) -> Data.store cond gid (value r).address (v.coerce_elt (value x)); v.Void // TODO too coarse; could force a truncation
    | Call("@elem_set_u32", r::xs) -> // each digit must be treated as *unsigned*
                                      let x = List.fold (fun x d -> x * v.two32 + (value d).uint32) v.zero xs
                                      let e = v.coerce_elt x // TODO too coarse, could force truncations
                                      Data.store cond gid (value r).address e; v.Void
    | Call("@elem_rand"   , [r] )  -> fieldOp0 (v.Elt (Field.t.random())) r // should be treated as a fresh local
    | Call("@elem_free"   , [r] )  -> fieldOp0 (v.Void) r // clearing to detect some read-after-free
    | Call("@elem_modinv" , [r;a]) -> fieldOp1 (fun x -> v.Elt Field.t.one / x) r a
    | Call("@elem_div2"   , [r;a]) -> fieldOp1 (fun x -> x / v.Int 2) r a   
    | Call("@elem_mul3"   , [r;a]) -> fieldOp1 (fun x -> x * v.Int 3) r a   
    | Call("@elem_copy"   , [r;x]) -> Data.store cond gid (value r).address (load x); v.Void
    | Call("@elem_neg"    , [r;a]) -> fieldOp1 (fun x -> v.neg x) r a
    | Call("@elem_add"   ,[r;a;b]) -> fieldOp2 (gadd) r a b
    | Call("@elem_sub"   ,[r;a;b]) -> fieldOp2 (gsub) r a b  
    | Call("@elem_mul"   ,[r;a;b]) -> fieldOp2 (*) r a b 
    | Call("@elem_get_bit", [a;x]) -> (load a).bit (value x).native 
    | Call("@elem_width",[r;a;x])  -> fieldOp1 (fun v -> v.bound (QAP.Range.uint (value x).native)) r a 
    | Call("@elem_eq_zero", [a])   -> let x = load a in (*printfn "eqz? %A" x.elt;*) v.zerop x 
    | Call("@elem_cmp"    , [a;b]) -> v.Int (Field.t.cmpf ((load a).elt, (load b).elt))
    | Call("@elem_dbg_print",[p])  -> printf "%A" (load p).Arith;  v.Void  

    // primitive definitions for whole-program proving and verifying, not used for key generation
    #if Gen
    #else
    | Call(f,[i0;i]) when f = (if Bank.bootstrap then "@__Enter_BOOT" else "@__Enter") ->
                                      Bank.outsourced <- []
                                      let f = Bank.s.functions.[(value i0).native]
                                      match mode with 
                                        | Prove  -> QAP.load f.qap; Val.Run.enter(); nop := 0; v.one  // f's code gets executed next
                                        | Verify -> v.zero // Verify("f",...) gets called next 
    | Call(f,i0::i::args) when f = (if Bank.bootstrap then "@Verify_BOOT" else "@Verify") ->
                                      // in Verify-mode, we verify a proof and build the result instead of calling the outsourced function
                                      let callee   = (value i0).native // function index
                                      let instance = (value i).native  // proof index
                                      let f = Bank.s.functions.[callee]
                                      // from the arguments to the proof ts
                                      // we could have cached that information as we compiled; we recompute it here for now.
                                      let resultType, formals, _ = VM.Code.findFunDef ("@"+f.name)
                                      let ts = 
                                        List.map2 
                                          (fun (typ,_) arg ->
                                            match Bank.of_type typ with 
                                            | Some b -> b.name, (loada (value arg).address).native
                                            | None   -> failwith "compile-time arguments not supported yet" )
                                          formals args
                                      // the result, presumed to be a fresh bank of its type.
                                      let br = 
                                        match Bank.of_type resultType with
                                        | Some b -> b
                                        | None   -> failwith "assuming a bank result for now"   
                                      let vr = eval cond gid (Call("@alloc_"+br.name,[])) // brittle
                                      let tr = (loada vr.address).native
                                      Bank.outsourced <- ts @ [br.name, tr] // setting the verification context
                                      Bank.Verify.proof instance callee     // setting the primitive result bank instance 
                                      if Lib.bv then printfn "[%5d.%5d ] return verified proof on %A" callee instance Bank.outsourced
                                      vr
    | Call(f,[i0;i]) when f = (if Bank.bootstrap then "@__Exit_BOOT" else "@__Exit") ->
                                      let callee = (value i0).native
                                      let instance = (value i).native
                                      match mode with 
                                      | Prove  -> 
                                          let internals = Array.init Val.Run.inter.Count (fun i -> Val.Run.inter.[i+1])
                                          Bank.Prove.proof instance callee internals
                                          if Lib.bv then printfn "[%5d.%5d ] return with proof on %A (%d steps)" callee instance Bank.outsourced !nop
                                          // Bank.Verify.proof instance callee // optional
                                      | Verify -> 
                                          () // assuming Bank.outsourced was populated by the call 
                                      v.Void
    #endif
    | Call(f,[b;p]) when Lib.w && f.StartsWith "@load_" // $fix clash on C function names! 
                               && Map.exists (fun name _ -> name = f.Substring 6) Bank.s.banks ->

                                      let a = (value p).address
                                      let name = f.Substring 6 // retrieve bank from the function name
                                      let bank = Bank.bank name
                                      let size = bank.spec.Length
                                      // we could check consistency of loading from this bank now 

                                      #if Gen
                                      // we don't care what b is; we fill p with pre-allocated bank variables
                                      let values = Val.getbank name 
                                      if Lib.bv then printfn "[    ?       ] load %s (%d unknown integers)" name size  
                                      Array.iteri (fun k v -> storea (a + k) v) values // copy all values into a
                                      v.Void
                                      #else
                                      // we load the values from the abstract bank state, 
                                      // turning them into Vars or natives depending on the mode.
                                      let callee, instance = (loada (Bank.state_function())).native, (loada (Bank.state_instance())).native
                                      let bv = (value b).address
                                      let t  = (loada bv).native
                                      let top = (callee = Bank.TOP_LEVEL)
                                      if not top then Bank.outsourced <- Bank.outsourced @ [name,t]
                                      let values = bank.values.[t]
                                      if Lib.bv then printfn "[%5d.%5d ] load %s %d (%d integers)" callee instance name t size //values
                                      let intify (e: Field.t) = v.Int(int e.Big)
                                      let wrap = if top then intify else v.Var
                                      Array.iteri (fun k e -> storea (a+k) (wrap e)) values
                                      v.Void // can't eval cond gid (Call("@load0_"+name,[b;p]))
                                      #endif

    // nothing special for | Call(f,[]) when Lib.w && f.StartsWith "@alloc_" -> 
    // we just increment and return the bank number.

    | Call(f,[b;p]) as call when Lib.w && f.StartsWith "@store_" 
                                       && Map.exists (fun name _ -> name = f.Substring 7) Bank.s.banks ->

                                      let a = (value p).address
                                      let name = f.Substring 7 // retrieve the bank from the function name
                                      let bank = Bank.bank name
                                      let size = bank.spec.Length
                                      // we could check consistency of storing to this bank now

                                      #if Gen
                                      if Lib.bv then printfn "[    ?       ] save %s (%d unknown integers)." name size  
                                      let k0 = Val.k0.[name]
                                      for k = 0 to size - 1 do
                                        let v = loada (a + k)  
                                        if Lib.v then printfn "%s[%d] := %A" name k v
                                        QAP.wireOutput (k0 + k) v.output 
                                      v.Void

                                      #else
                                      let callee, instance = (loada (Bank.state_function())).native, (loada (Bank.state_instance())).native
                                      let bv = (value b).address
                                      let t  = (loada bv).native
                                      let values = 
                                        if callee = Bank.TOP_LEVEL then 
                                          // an input computed by the verifier: save values & compute the commitment TODO
                                          Array.init size (fun k -> Field.t.ofInt32 (loada (a+k)).native)
                                            
                                        else
                                          // either an output (received & recomputed) or a prover commitment
                                          // first get the "outer" native values, then process the commitment TODO
                                          Bank.outsourced <- Bank.outsourced @ [name,t]
                                          Array.init size 
                                            (fun k -> let v = loada (a + k) 
                                                      if Lib.v then printfn "%d -> %A" k v
                                                      v.output ) // may trigger truncation
                                                           
                                      if Lib.bv then printfn "[%5d.%5d ] save %s %d (%d integers)" callee instance name (loada bv).native size //values 
                                      bank.values <- bank.values.Add(t,values)
                                      // can't eval cond gid (Call("@store0_"+name,[b;p]))
                                      v.Void 
                                      #endif
 
     // we should have more uniform naming conventions...
    | Call("@load_int32s",[prefix;index;size;dst;flag]) ->
                                      let s = (value size).native
                                      let t = LLVM.Array(s, LLVM.Int 32)
                                      let r = loadfile (vstring prefix) (value index).native t (value dst) ((value flag).native = 1) 
                                      //printfn "loaded %A [%d]" r s 
                                      r
    | Call("@load_cCommitment" as f,[prefix;dst;index;flag]) ->
                                      let tname = f.Substring 6        
                                      let t = Tvar("%struct." + tname)
                                      loadfile ("commit-" + vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call("@load_cProof" as f,[prefix;dst;index;flag]) ->
                                      let tname = f.Substring 6        
                                      let t = Tvar("%struct." + tname)
                                      loadfile ("proof-" + vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,[prefix;dst;index;flag]) when f.StartsWith "@load_" ->
                                      let tname = f.Substring 6        
                                      let t = Tvar("%struct." + tname)
                                      loadfile (vstring prefix) (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,[dst;index;flag]) when f.StartsWith "@load_" ->
                                      let tname = f.Substring 6        
                                      let t = Tvar("%struct." + tname)
                                      loadfile tname (value index).native t (value dst) ((value flag).native = 1)
    | Call(f,args) -> 
                      if Lib.i then printfn "calling %s" f
                      call mode cond gid f (List.map value args)

    | Phi(join)    -> failwith "Internal error: Phi should have been dealt with outside of eval" 
                      // phi (match Lib.find xp.lastlabel join with Some x -> x | None -> Void)
    | Load(x)      -> load x // Maybe redundant, but llvm optimizer rarely leaves redundant loads
    | Addr(t,a,vs) -> 
                      let ns = List.map (fun v -> int32 (value v).native) vs
                      let offset = Code.offset t ns
                      // partial support: printfn "Addr %A %A %A + %d" t a vs offset
                      v.Address((value a).address + offset) 
    | Alloc(t)     -> v.Address (Data.alloc (Code.tSize t))
    | AllocN(t,x)  -> v.Address (Data.alloc (Code.tSize t * (value x).native))
    | BitCast(_t,x) -> value (Var x)
    //| e            -> failwithf "not yet implemented: %A" e
  // end of let eval...

  let result = ref None 
  let predCount = Map.map (fun _ -> List.length) <| CfgAnnotator.mkIndegs (CfgAnnotator.LLVMCfg(xp.Segment))

  (* Used right before executing a branch: returns a frame for the next
     basic block. Looks ahead at the Phi() instructions of the destination
     and copies current variables to the next frame. The next frame is then returned
     We still need to copy the formal parameters, which is not done here.
     Assumes !frame and xp.label are still unchanged
  *)
  let phiAssocs value gid dest = 
    let destblock = List.find (fun b -> b.label = dest) blocks
    let destphi = List.choose (function 
                    | Let(v,Phi p) -> let (_,src) = List.find (fun (l,_) -> l=xp.Label) p
                                      let v2 = value <| match src with None -> Void | Some x -> x
                                      Some (v,(v2,gid))
                    | _ -> None) destblock.instr
    Map.ofList destphi

  let phiVars dest = // Same as Map.keys (phiAssocs dest)
    let destblock = List.find (fun b -> b.label = dest) blocks
    List.choose (function  Let(v,Phi _) -> Some v | _ -> None) destblock.instr

  let (&&&) (a:v) (b:v) = 
    let toBit (x:v) = (*if x.isBit then x else*) v.one - v.zerop x
    if   a = v.zero || b = v.zero then v.zero
    elif a = v.one then toBit b
    elif b = v.one then toBit a
    else toBit a * toBit b

  // We need this function because we can't compare v types inside (-)
  let nestedConds (outer:v) (inner:v) = 
    if   outer = v.zero then v.zero, v.zero
    elif inner = v.one  then v.zero,  outer
    elif inner = v.zero then  outer, v.zero
    else
        let c1 = outer &&& inner
        let c0 = (outer - c1).bound QAP.Range.bit // could switch to using bitNeg here
        c0, c1

  (* /*S
     Executes a single 'branch' of code under a given condition. 
     This could be just unconditionally true (if we are executing
     the topmost statements in the entry function), or something else
     if we are executing just one branch of an if-else (possibly nested) 

     Parameters:
     cond, gid : The condition under which this branch is to be executed
                 and the unique guard-identifier to help equality checks
                 between conditions. cond may be:
                 unknown    - the condition depends on runtime inputs
                 true       - we have not yet taken any conditional branches
                 knownFalse - this branch doesn't have to be executed,
                              but we still need the info in the return value
                              to figure out where we are ending
     toplevel :  true if we have not yet seen any (runtime) conditional
                 branches in this function. This is in contrast to cond.knownTrue, 
                 which indicates that we have not seen any conditional branches 
                 at all, be it in this function or the caller functions.
     lbl0 :      The starting basic block label

     Return values (not important once we have executed Return):
     endLabel : string
         The label of the basic block that ends this branch. E.g., in
         a branch on a runtime condition, we expect the two branches to 
         merge back to the same endLabel. This is the end block.
     joinCount : int
         The number of branches or paths that have already merged into
         the basic block at endLabel. This value strictly greater than zero. 
         It is compared with the number of ancestors of the end block to see
         if they are equal. If equal, it means we have executed all branches
         and leading into endLabel, and we can execute the endLabel block
         now. If joinCount < ancestorCount, there are other pending paths from
         conditions seen in previous branches that are merging here as well.
         */
     *)

  let rec execBranch toplevel (cond:v) (gid:guardid) lbl0 : string * int = 
      let value v = valueWrt cond gid frame v
      let lblc = ref lbl0
      let joinCount = ref 1
      let branchFrameResolved dest = 
          lblc := dest
          xp.Goto dest
          if not (cond = v.zero) && Lib.i then printfn "branch %s" dest
      let branch dest =
          if not (cond = v.zero) then  
              let newvars = phiAssocs value gid dest
              frame := Lib.mapUnion !frame newvars
          branchFrameResolved dest
      branch lbl0
      while (!result).IsNone && (predCount.[!lblc] = !joinCount || toplevel) do
        joinCount := 1
        let op = xp.Next 
        if Lib.i then
          let nw, nr = 
            #if Gen 
            QAP.nWire, QAP.nRoot 
            #else
            Val.Run.nWire, QAP.nRoot 
            #endif
          printf "%8d +%6d (%6dw,%6dr) | " !nc Data.top nw nr

        incr nop;
        match op with
        | Let(_, Phi _) -> () // this was handled during the branch, nothing else needs to be done
        | Let(r,e)      -> if cond <> v.zero then 
                             let v = eval cond gid e
                             set r gid v // no conditioning for local assignments 
                             if Lib.i then printfn "%s = %A" r v
        | Store(a,x)    -> 
                           let l = (value a).address
                           let v = value x
                           Data.store cond gid l v
                           if Lib.i then 
                             printfn "%A <- %A" l v  
        | Branch(lbl)   -> branch lbl
        | BranchIf(z,l1,l0) ->
                    let x = get z 
                    if not x.unknown && toplevel 
                    then 
                      // static branch
                      branch (if x.True then l1 else l0)
                    elif not Lib.fork then failwith "Branching on runtime conditions disabled at command line"
                    else 
                        // LLVM invariant: x must be in 0..1
                        // either starting or already in conditional execution
                        let branchAndReset c lbl = 
                            let f0 = !frame
                            let start = xp.Label
                            let gid = nextguard()
                            let (endl,jc) = execBranch false c gid lbl
                            let f1 = !frame  
                            xp.Goto start
                            frame := f0  // maybe execBranch should have a 'frame' param? Someday...
                            Data.cache := DataCache.evictByGuard gid !Data.cache
                            (endl,jc,f1,gid)
                        let c0,c1 = nestedConds cond x
                        let end0, jc0, f0, g0 = branchAndReset c0 l0
                        let end1, jc1, f1, g1 = branchAndReset c1 l1
                        if end0<>end1 then failwith "Invalid control flow; only if/else is supported under runtime control"
                        joinCount := jc0 + jc1
                        // cond can become knownFalse here when executing the cond2 branch here:
                        // if (cond) { if (knownFalse) { if(cond2) { ... } } }
                        if not cond.knownFalse then
                            if x.unknown then 
                                let mapkeys m = List.map fst (Map.toList m)
                                let newframe : frame = Map.ofList <| List.map (fun v -> 
                                          let v0 = valueWrt c0 g0 (ref f0) <| Var v
                                          let v1 = valueWrt c1 g1 (ref f1) <| Var v
                                          match v0,v1 with
                                          | v.Address a0,v.Address a1 when a0=a1 -> (v,(v0,gid))
                                          | _ -> (v,((v0+v1),gid))) (phiVars end0)
                                frame := Lib.mapUnion !frame newframe
                            elif x = v.one then frame:=f1
                            else frame:=f0
                        branchFrameResolved end0
        | Switch(x,l0,branches) ->
                        if (get x).unknown || cond.unknown then failwith "Switches in conditionals: not implemented"
                        let s = get x
                        let l =  
                            match List.tryFind (fun (c,l) -> (v.zerop (value c - s)).True) branches with 
                            | Some (_,l) -> l
                            | None       -> l0
                        branch l 
        | Return(x) -> 
                      if not toplevel then failwith "Cannot return from a conditional context"
                      result := Some(value x)
                      if Lib.i then printfn "return %A from %s" result f 
      (!lblc,!joinCount)

  // execute the function call 
  let _,_ = execBranch true cond gid0 xp.Label
  assert (!result).IsSome
  Data.pop()
  (!result).Value

 //with exn -> printfn "from calling %s" f; raise exn // for tracing, otherwise not great


//----------------- toplevel for outsourced functions 

// pushes an array of values onto the data stack
let pushArray (vs:v array) = 
  let p = Data.alloc vs.Length
  Array.iteri (fun i v -> Data.storeRaw (p+i) v) vs // only used in unconditional contexts
  v.Address p

/// update an array from values read off the stack
let private pullArray (p:Data.address) ns = 
  //printfn "Pushing p=%d %A" p ns
  for i = 0 to Array.length ns - 1 do ns.[i] <- (Data.loadRaw (p+i)).native // same here, uncond only

// evaluate top-level (only used by QAPEval for now) 
let main mode = 
  let name = "main"
  let gid = nextguard()
  let actuals = []
  let exitval = call mode v.one gid "@main" actuals
  exitval.native

// evaluate outsourced code
let eval f (actuals: (string * Bank.v) list) (banks: Bank.b array) =
  Data.init() // reset the global state; reconsider with Lib.w
  let mode = Prove // dummy
  #if Gen
  QAP.init()
  #else
  Val.Run.enter()
  #endif

  // Push the actual parameters onto the data stack
  let frame =
    List.map
      (fun (name,actual) -> 
          match actual with
            | Bank.Cfg ns -> 
                let vs = Array.map v.Int ns 
                pushArray vs
            | Bank.Bank b ->
                if Lib.w then v.Int 42
                else
                  let vs = 
                    #if Gen 
                    Val.bank b.name b.spec.Length //$ refine
                    #else
                    b.value
                    #endif
                  pushArray vs ) 
      actuals

  // In the new mode (Gen-only), force the allocation of public banks, then shared banks 
  if Lib.w then 
    Val.banks <- Array.map (fun (b:Bank.b) -> b.name, Val.bank b.name b.spec.Length) banks

  // Evaluate the function
  if Lib.i then Data.print()
  let gid = nextguard()
  if Lib.w then 
    let init = if Bank.bootstrap then "@init_BOOT" else "@init"
    let _    = call mode v.one gid init [] in ()
  let result = call mode v.one gid f frame
  if Lib.i then Data.print()

  // Retrieve the results from the data stack
  if not Lib.w then
    let _k = 
      List.fold2
       (fun k (name,actual) (v:v) ->
        match actual with 
        | Bank.Cfg ns -> pullArray v.address ns ; k // copy back all compile-time final values
        | Bank.Bank b ->
            let size = b.spec.Length
            let p = v.address
            #if Gen 
            // For each assignment into a bank, equate the final value and its wire.                 
            for i = 0 to size-1 do 
              let final = Data.loadRaw (p+i)
              let used = not(QAP.free (k+i)) 
              let assigned = not (final.isWire (k+i))
              QAP.Log.record (QAP.Log.Output assigned)
              match used, assigned with 
              | true , false -> () // input wire
              | true , true  -> failwithf "%s[%d] used both for input and output" name i
              | false, false -> printfn "Warning: %s[%d] unused" name i  
              | false, true  -> 
                  if Lib.i then printfn "%s[%d] <- %A" name i final
                  QAP.wireOutput (k+i) final.output // may cause a truncation (assumption: never the first use of another bank variable) 
            #else
            // For each assignment into a bank, optionally record the final value  
            for i = 0 to size-1 do
              let final = Data.loadRaw (p+i)
              let assigned = 
                match QAP.Log.hint() with 
                | QAP.Log.Output b -> b
                | _  -> failwith "bad hint"          
              if assigned then 
                let v = final.output // may cause a truncation 
                b.value.[i] <- Val.Run.Var v
            #endif            
            k + size )         

       1 
       actuals
       frame
    ()

  #if Gen
  if Lib.e then
      // printfn "--- The output wires are %d..%d" isize (isize + osize - 1)
      // printfn "--- Final state" ; display finalState 
      // Map.iter (fun k v -> printfn "wire %4d %A" k v) QAP.wire
      QAP.print()
  let qap = QAP.save()
  qap
  #else
  // TODO return the final state, doing the same final.output

  if Lib.h then 
          let histogram  = Array.zeroCreate 255; 
          Map.iter (fun _ (x: Field.t) -> let i = QAP.log2 (x.Big + QAP.one) in histogram.[i] <- histogram.[i] + 1) Val.Run.inter
          printfn "#bit #variable\n"
          Array.iteri (fun i n -> if n <> 0 then printfn "%3d %7d" i n) histogram

  if Lib.v then 
    //printfn "The outputs are %A" outputs
    printfn "The internal values are %A." Val.Run.inter
  //outputs
  #endif
