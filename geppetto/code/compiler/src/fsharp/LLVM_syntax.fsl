{ 

// This file is generated by
// /cygdrive/c/Program\ Files\ \(x86\)/FSharpPowerPack-4.0.0.0/bin/fslex.exe LLVM_syntax.fsl --unicode
//
// it provides a limited lexer for LLVM .S files produced by CLANG. 

module Lexer
open LLVM_grammar

}

let digit = ['0'-'9']
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')
let letter = ( ['a'-'z'] | ['A'-'Z'] )
let char = ( digit | letter | '.' | '_' | '-')
let anyline = ( whitespace | '!' | ['#'-'&'] | ['('-'~'] )
let any = ( anyline | newline )

rule token = parse
| whitespace      { token lexbuf }
| newline         { lexbuf.EndPos <- lexbuf.EndPos.NextLine; NEWLINE }
| "("             { LPAREN }
| ")"             { RPAREN }
| "*"             { STAR }
| ","             { COMMA }
| ":"             { COLON }
| ";"(anyline|'\'')* { COMMENT }
| "<label>"       { SQLABEL }
| "="             { EQUALS }
| "["             { LBRACKET }
| "]"             { RBRACKET }
| "ModuleID"      { MODULEID }
| "add"           { ADD }
| "and"           { AND }
| "ashr"          { LSHR }
| "align"         { ALIGN }
| "alloca"        { ALLOCA }
| "bitcast"       { BITCAST }
| "br"            { BR }
| "byval"         { BYVAL }
| "call"          { CALL }
| "common"        { COMMON }
| "constant"      { CONSTANT }
| "declare"       { DECLARE }
| "define"        { DEFINE }
| "eq"            { EQ }
| "exact"         { EXACT }
| "false"         { INT(0) }
| "fastcc"        { FASTCC }
| "getelementptr" { GEP }
| "global"        { GLOBAL }
| "icmp"          { ICMP }
| "inbounds"      { INBOUNDS }
| "internal"      { INTERNAL }
| "i1"            { INT1 }
| "i8"            { INT8 }
| "i16"           { INT16 }
| "i32"           { INT32 }
| "i33"           { INT32 }
| "i64"           { INT64 }
| "label"         { LABEL }
| "load"          { LOAD } 
| "lshr"          { LSHR } 
| "mul"           { MUL }
| "ne"            { NE }
| "nsw"           { NSW }
| "null"          { NULL }
| "nuw"           { NUW }
| "noalias"       { NOALIAS }
| "nocapture"     { NOCAPTURE }
| "nounwind"      { NOUNWIND }
| "opaque"        { OPAQUE }
| "or"            { OR }
| "phi"           { PHI }   
| "preds"         { PREDS }
| "private"       { PRIVATE }
| "readnone"      { READNONE }
| "readonly"      { READONLY }
| "ret"           { RETURN }
| "select"        { SELECT }
| "sext"          { SEXT }
| "sge"           { SGE }
| "sgt"           { SGT }
| "shl"           { SHL }
| "signext"       { SIGNEXT }
| "sle"           { SLE }
| "slt"           { SLT }
| "srem"          { SREM }
| "store"         { STORE }
| "sub"           { SUB }
| "switch"        { SWITCH }
| "tail"          { TAIL }
| "target"        { TARGET }
| "to"            { TO } 
| "true"          { INT(1) } 
| "trunc"         { TRUNC } 
| "type"          { TYPE }
| "ult"           { ULT }
| "ugt"           { UGT }
| "undef"         { UNDEF }
| "unnamed_addr"  { UNNAMEDADDR }
| "void"          { VOID }
| "x"             { CROSS }
| "xor"           { XOR }
| "zeroinitializer" { ZEROINITIALIZER }
| "zext"          { ZEXT }
| "{"             { LBRACE }
| "}"             { RBRACE }
| '!'             { MVAR } 
| "..."           { ETC }
| '.'char*        { DOTVAR(new string(lexbuf.Lexeme))}
| 'c''"'any*'"'   { STRING(new string(lexbuf.Lexeme)) } 
| '"'any*'"'      { STRING(new string(lexbuf.Lexeme)) } 
| '\''any*'\''    { STRING(new string(lexbuf.Lexeme)) } 
| '%'char+        { VAR(new string(lexbuf.Lexeme)) }
| '@'char+        { VAR(new string(lexbuf.Lexeme)) }
| '#'digit+       { ABBREV }
| ['-']?digit+    { INT (System.Int32.Parse(new string(lexbuf.Lexeme))) }
| eof             { EOF }
| char+           { WORD(new string(lexbuf.Lexeme)) }

