%{
open LLVM

// This file is generated by fsyacc
//
// it provides a limited parser for LLVM .S files produced by CLANG. 

let parse_error x = 
  failwithf "parsing error: %A" x
%}

%start start
%token <string> STRING
%token <string> VAR
%token <string> DOTVAR
%token <string> WORD
%token <System.Int32> INT

%token ADD
%token AND
%token ABBREV
%token ALIGN
%token ALLOCA
%token BITCAST
%token BR
%token BYVAL
%token CALL
%token COLON
%token COMMA
%token COMMENT
%token COMMON
%token CONSTANT
%token CROSS
%token DECLARE
%token DEFINE
%token EOF
%token EQ
%token EQUALS
%token ETC
%token EXACT
%token FASTCC
%token GEP
%token GLOBAL
%token ICMP
%token INBOUNDS
%token INTERNAL
%token INT1
%token INT8
%token INT16
%token INT32
%token INT64
%token LABEL
%token LANGLE
%token LBRACE
%token LBRACKET
%token LOAD
%token LPAREN
%token LSHR
%token MODULEID
%token MUL
%token MVAR
%token NE
%token NEWLINE
%token NOALIAS
%token NOCAPTURE
%token NOUNWIND
%token NSW
%token NUW
%token NULL
%token OPAQUE
%token OR
%token PHI
%token PREDS
%token PRIVATE
%token RANGLE
%token RBRACE
%token RBRACKET
%token READNONE
%token READONLY
%token RETURN
%token RPAREN
%token SELECT
%token SEMI
%token SEXT
%token SGE
%token SGT
%token SHL
%token SIGNEXT
%token SLE
%token SLT
%token SREM
%token SUB
%token SWITCH
%token SQLABEL
%token STAR
%token STORE
%token TAIL
%token TARGET
%token TRUNC
%token TO
%token TYPE
%token ULT
%token UGT
%token UNDEF
%token UNNAMEDADDR
%token VOID
%token XOR
%token ZEROINITIALIZER
%token ZEXT

%type < decl list > start
%type < block > block

%%

start: decls { $1 }

op: VAR { Var($1) } 
  | INT { Const($1) }
  | NULL { Void }
  | UNDEF { Var("undef") }
  | GEP INBOUNDS LPAREN typ op indexes RPAREN{ Computed($4,$5,$6) }
  | BITCAST LPAREN typ op TO typ RPAREN { $4 }
 /* | GEP INBOUNDS typ op indexes  { Var("TODO!") } */

whatever: 
  | COMMA ALIGN INT COMMA MVAR WORD MVAR INT { () }
  | COMMA ALIGN INT { () } 
  | {}

/* todo: recheck unsigned int semantics */                                             

errors:
  | NUW NSW { () }
  | NUW { () }
  | NSW { () }
  | {}

expr: 
  | ADD errors typ op COMMA op  { Add($4,$6) }
  | SUB errors typ op COMMA op  { Sub($4,$6) }
  | AND        typ op COMMA op  { And($3,$5) }
  | OR         typ op COMMA op  {  Or($3,$5) }
  | XOR        typ op COMMA op  { Xor($3,$5) }
  | SHL errors typ op COMMA op  { Shl($4,$6) }
  | LSHR EXACT typ op COMMA op  { Shr($4,$6) }  
  | LSHR       typ op COMMA op  { Shr($3,$5) }
  | MUL errors typ op COMMA op  { Mul($4,$6) }
  | SREM       typ op COMMA op  { Srem($3,$5) }

  | ZEXT    typ op TO typ    { Zext($3) }
  | TRUNC   typ op TO typ    { Zext($3) }  // coarse
  | SEXT    typ op TO typ    { Zext($3) }

  | ICMP EQ typ op COMMA op  {  Eq($4,$6) }
  | ICMP NE typ op COMMA op  {  Neq($4,$6) }
  | ICMP SGE typ op COMMA op  { Sge($4,$6) }
  | ICMP SLE typ op COMMA op  { Sle($4,$6) }
  | ICMP SGT typ op COMMA op  { Sgt($4,$6) }
  | ICMP SLT typ op COMMA op  { Slt($4,$6) }
  | ICMP ULT typ op COMMA op  { Ult($4,$6) }
  | ICMP UGT typ op COMMA op  { Ugt($4,$6) }
  | LOAD typ op whatever      { Load($3) }
  | GEP INBOUNDS typ op indexes { Addr($3,$4,$5) }
  | GEP          typ op indexes { Addr($2,$3,$4) }
  | SELECT typ op COMMA typ op COMMA typ op { Select($3,$6,$9) }
  | PHI typ pres           { Phi($3) }
  | ALLOCA typ COMMA ALIGN INT { Alloc($2) }
  | ALLOCA typ COMMA INT32 op COMMA ALIGN INT { AllocN($2,$5) }
  | BITCAST typ VAR TO typ     { BitCast($5,$3) }
  | callhdr typ call           { $3 }
/*  | BITCAST LPAREN typ expr TO typ RPAREN  { BitCast($6,$4) } */

pre: 
  | LBRACKET op    COMMA VAR RBRACKET { $4,Some $2 } 
  | LBRACKET UNDEF COMMA VAR RBRACKET { $4,None } 

pres: pre           { [$1] } 
  | pre COMMA pres  { $1::$3}

indexes:
  | COMMA typ op indexes { $3 :: $4 } 
  |              { [] } 

label: LABEL VAR { $2 }

nounwind: NOUNWIND {} | ABBREV {} | {} 

// we ignore these subtleties
callhdr:
  | TAIL callhdr {} 
  | CALL FASTCC {}
  | CALL {}
calltail:
  | ABBREV calltail {} 
  | COMMA MVAR WORD MVAR INT {}
  | {}

// specific to printf : tail call i32 (i8*, ...)* @printf... 
// and to Verify, e.g. call i8* (i32, i32, ...)* @Verify...
vartyp:
  | LPAREN INT8 STAR         COMMA ETC RPAREN STAR {}
  | LPAREN INT32 COMMA INT32 COMMA ETC RPAREN STAR {}


call: 
  | vartyp call { $2 }
  | VAR LPAREN args RPAREN calltail { Call($1,$3) }

// switches
branches:
  | INT32 op COMMA label NEWLINE branches { ($2,$4)::$6 }
  | RBRACKET { [] }

line: 
   | VAR EQUALS expr                     { Let($1,$3)  }
   | STORE typ op COMMA typ op whatever  { Store($6,$3) }
   | BR label                            { Branch($2) }
   | BR INT1 VAR COMMA label COMMA label { BranchIf($3,$5,$7) }
   | SWITCH INT32 VAR COMMA label LBRACKET NEWLINE branches { Switch($3,$5,$8) }
   | callhdr VOID call                   { Let("%null",$3) }
   | RETURN VOID                         { Return(Void) }
   | RETURN typ op                       { Return($3) }

lines: 
	| line NEWLINE lines { $1 :: $3 }
	|                    { [] } 

/* to be refined */
typ: VAR        { Tvar $1 }        
   | INT1       { Int 1  } 
   | INT8       { Int 8  } 
   | INT16      { Int 16 } 
   | INT32      { Int 32 } 
   | INT64      { Int 64 } 
   | LBRACKET INT CROSS typ RBRACKET { Array($2,$4) } 
   | LBRACE typs RBRACE { Struct($2) }
   | LPAREN typ RPAREN { $2 }  
   | OPAQUE     { Tvar "opaque" }
   | VOID       { TVoid }
   | ETC        { TVoid } // approx. for vararg types
   | typ STAR   { Ptr $1 } 

   | SIGNEXT typ { $2 }
   | typ SIGNEXT { $1 }
   | typ NOCAPTURE       { $1 } 
   | typ READNONE        { $1 } 
   | typ READONLY        { $1 } 
   | typ BYVAL ALIGN INT { $1 }


typs: typ COMMA typs  { $1::$3 } 
   |  typ             { [$1] } 
   |                  { [] } 

typDef: VAR EQUALS TYPE typ { TypeDef($1,$4) }

initializer: 
   | NULL            { None }
   | ZEROINITIALIZER { None }
   | INT             { Some($1) }

globalQualifier:
   | INTERNAL globalQualifier {}
   | COMMON   globalQualifier {}
   | GLOBAL   {}
   | CONSTANT {}

globalDef: 
   | VAR EQUALS globalQualifier typ initializer whatever { GlobalDef($1,$4,$5) }

globalStr: 
   | VAR EQUALS PRIVATE UNNAMEDADDR CONSTANT typ STRING COMMA ALIGN INT { GlobalStr($1,$7) }
   | VAR EQUALS PRIVATE UNNAMEDADDR CONSTANT typ STRING                 { GlobalStr($1,$7) }
   
/* We ignore a few of them */
decls: 
  | DECLARE funDecl           decls { $3 }
  | DEFINE funDef             decls { $2::$3 }
  | typDef                    decls { $1::$2 }
  | globalDef                 decls { $1::$2 }
  | globalStr                 decls { $1::$2 }
  | TARGET WORD EQUALS STRING decls { $5 } 
  | COMMENT NEWLINE           decls { $3 } 
  | NEWLINE                   decls { $2 }
  | MVAR                            { [] } 
  |                                 { [] }

words: WORD words  {}
  | NOUNWIND words {}
  | ABBREV words {}
  |                {}

funDef: 
  | NOALIAS funDef { $2 }
  | INTERNAL funDef { $2 }
  | FASTCC   funDef { $2 }
  | funSig funBody { FunDef($1,$2) }


funDecl: 
  | NOALIAS funDecl { () }
  | typ VAR LPAREN typs RPAREN words { () }

funSig: typ VAR LPAREN formals RPAREN words { $1,$2,$4 }
funBody: LBRACE NEWLINE blocks RBRACE { $3 }

formal: 
  | typ VAR           { $1,$2 }

formals: 
  | formal COMMA formals   { $1::$3 }
  | formal                 { [$1] }
  |                        { [] }

blocks: 
   | block                { [$1] }
   | block NEWLINE blocks { $1::$3 }

vars: 
   | VAR COMMA vars { $1::$3 } 
   | VAR            { [$1] }

preds: 
   | SEMI PREDS EQUALS vars  { () }
   |                         { () }

/* ad hoc block headers */ 
block: lines                                       { mkBlock "%0"              $1 }
     | WORD COLON         NEWLINE lines            { mkBlock ("%" + $1)        $4 }
     | WORD COLON COMMENT NEWLINE lines            { mkBlock ("%" + $1)        $5 }
	 /*
     | SEMI SQLABEL COLON WORD preds NEWLINE lines { mkBlock ("%" + $4)        $7 }
     | SEMI SQLABEL COLON INT  preds NEWLINE lines { mkBlock ("%" + string $4) $7 }
     | DOTVAR COLON preds NEWLINE lines            { mkBlock ("%" + string $1) $5 } */

/* limited form for byval align 4; could move to typ */
arg: 
   | typ op { $2 }

args: arg COMMA args  { $1::$3 }
    | arg             { [$1]   }
    |                 { []     }

   